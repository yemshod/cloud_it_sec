Excellent — now you're elevating to **infrastructure as code + CI/CD**, using GitHub Actions to automate Terraform deployment per account, with the **modular structure**, **centralized state per account**, and **GitHub-based change control**.

Let’s refactor your model to support **GitHub Actions** (CI pipeline) for each account, while still maintaining:

- Modular departments (`networking/`, `security/`, etc.)
- Single shared state file per account (`account1-central.tfstate`, etc.)
- Remote backend in S3 per account
- GitHub Actions workflows per account folder

---

## **Refactored Pipeline Strategy Overview**

| Component           | Design                                                           |
|---------------------|------------------------------------------------------------------|
| **Folder structure**| Modular per department under `accounts/accountX/`               |
| **Terraform state** | One S3-based state file per account (`account1-central.tfstate`) |
| **GitHub Actions**  | One reusable workflow, triggered per account                    |
| **Secrets**         | Store account credentials securely as GitHub Actions secrets     |

---

## **Step-by-Step GitHub Actions Setup**

---

### **Step 1: Store Account Credentials as GitHub Secrets**

For each AWS account, store the credentials (or role-to-assume parameters) securely in GitHub. If using static credentials:

| Secret Name                     | Description                       |
|----------------------------------|-----------------------------------|
| `AWS_ACCOUNT1_ACCESS_KEY_ID`     | IAM user or automation key        |
| `AWS_ACCOUNT1_SECRET_ACCESS_KEY` | Secret for above                  |
| `AWS_ACCOUNT1_REGION`            | (optional) AWS region like `us-east-1` |

---

### **Step 2: Create Terraform GitHub Workflow File**

**File:** `.github/workflows/terraform-account1.yml`

```yaml
name: Terraform Deployment - Account1

on:
  push:
    paths:
      - 'accounts/account1/**'
    branches:
      - main

jobs:
  terraform:
    name: 'Terraform Apply - Account1'
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: accounts/account1

    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCOUNT1_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_ACCOUNT1_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_ACCOUNT1_REGION }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.6

    - name: Terraform Init
      run: terraform init -backend-config="backend.s3.tfbackend"

    - name: Terraform Plan
      run: terraform plan -var-file="terraform.tfvars"

    - name: Terraform Apply
      if: github.ref == 'refs/heads/main'
      run: terraform apply -auto-approve -var-file="terraform.tfvars"
```

---

### **Step 3: Backend & Folder Setup**

In `accounts/account1/backend.s3.tfbackend`:
```hcl
bucket         = "tfstate-account1"
key            = "account1-central.tfstate"
region         = "us-east-1"
dynamodb_table = "tf-locks-account1"
encrypt        = true
```

In `accounts/account1/terraform.tfvars`:
```hcl
region = "us-east-1"

tags = {
  account     = "account1"
  owner       = "terraform"
  environment = "prod"
}

aws_profile = ""
```

In `accounts/account1/networking/main.tf` and `security/main.tf`, put your resources or modules.

---

### **Step 4: Test Locally (One Time)**

Before triggering the pipeline:
```bash
cd accounts/account1/networking
terraform init -backend-config=../backend.s3.tfbackend
terraform plan -var-file=../terraform.tfvars
```

Make sure this works to avoid CI failures due to initialization or backend issues.

---

### **Step 5: Push to GitHub**

Once code is ready:
```bash
git add .
git commit -m "Refactor account1 with GitHub Actions support"
git push origin main
```

The workflow will trigger automatically when:
- Code under `accounts/account1/**` changes
- You push to `main` branch

---

### **Optional: Reusable Workflow for Multiple Accounts**

Instead of one workflow per account, use a **reusable composite action** and call it with account-specific parameters (`env`, secrets, paths).

---

### **Advanced Enhancements**

| Enhancement                 | Description |
|-----------------------------|-------------|
| **Manual Approvals**        | Use `workflow_dispatch` + `terraform plan` only on push, `apply` on approval |
| **Environment Protection**  | GitHub Environments + Required Reviewers |
| **Workspaces (if needed)**  | For different lifecycles (dev/stage/prod) in same account |
| **Cost-aware planning**     | Add cost estimation with infracost |
| **Slack/MS Teams alerts**   | Add status notifications to collaboration tools |

---

## **Visual Summary**

```
terraform-iam-multi-account/
├── .github/
│   └── workflows/
│       ├── terraform-account1.yml
├── accounts/
│   └── account1/
│       ├── terraform.tfvars
│       ├── backend.s3.tfbackend
│       ├── networking/
│       │   └── main.tf
│       ├── security/
│       │   └── main.tf
```

---
==============


Modular Terraform Deployment for Account1

Below is the complete repository structure for Account1. It defines a reusable Terraform module to create an IAM user with administrative access, and uses a GitHub Actions workflow to automatically run Terraform for each department (networking, security, engineering) in Account1. The Terraform state is stored remotely in a centralized S3 backend (with DynamoDB for state locking). The GitHub Actions pipeline uses a matrix strategy to initialize, plan, and apply Terraform in each department subfolder, with AWS credentials provided via GitHub Secrets.

.github/workflows/terraform-account1.yml

name: Terraform Deploy (Account1)

on:
  push:
    branches: [ "main" ]
    paths: 
      - "accounts/account1/**"    # Only run when files in account1 change
  workflow_dispatch:             # Allow manual trigger

jobs:
  terraform:
    name: Terraform Account1 (${{ matrix.department }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        department: [ "networking", "security", "engineering" ]
    defaults:
      run:
        working-directory: accounts/account1/${{ matrix.department }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.0

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCOUNT1_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_ACCOUNT1_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Initialize Terraform
        run: terraform init -backend-config=../backend.s3.tfbackend

      - name: Terraform Plan
        run: terraform plan -var-file=../terraform.tfvars

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'   # Only apply on main branch
        run: terraform apply -var-file=../terraform.tfvars -auto-approve

modules/iam-user/main.tf

// IAM user resource module - creates a user and attaches AdministratorAccess
resource "aws_iam_user" "this" {
  name = var.user_name
}

resource "aws_iam_user_policy_attachment" "admin_policy" {
  user       = aws_iam_user.this.name
  policy_arn = "arn:aws:iam::aws:policy/AdministratorAccess"
}

modules/iam-user/variables.tf

variable "user_name" {
  description = "The name of the IAM user to create with admin access"
  type        = string
}

accounts/account1/backend.s3.tfbackend

# Remote state backend configuration for Account1
bucket         = "my-central-terraform-state"      # S3 bucket for state storage
key            = "account1/terraform.tfstate"      # State file path within the bucket
region         = "us-east-1"                       # AWS region of the S3 bucket
dynamodb_table = "terraform-state-locks"           # DynamoDB table for state locking
encrypt        = true                              # Encrypt state file at rest

accounts/account1/terraform.tfvars

# Terraform variable values for Account1
user_name = "pri-git-action-user"   # IAM user name for the GitHub Actions user
region    = "us-east-1"             # AWS region for all resources in Account1

accounts/account1/networking/main.tf

// Terraform configuration for the Networking department in Account1
terraform {
  backend "s3" {}  # uses settings from ../backend.s3.tfbackend during init
}

provider "aws" {
  region = var.region
}

# Declare variables used in this configuration
variable "region" {
  description = "AWS region for resources"
  type        = string
}
variable "user_name" {
  description = "IAM user name to create"
  type        = string
}

module "iam_user" {
  source    = "../../modules/iam-user"
  user_name = var.user_name
}

accounts/account1/security/main.tf

// Terraform configuration for the Security department in Account1
terraform {
  backend "s3" {}
}

provider "aws" {
  region = var.region
}

variable "region" {
  description = "AWS region for resources"
  type        = string
}
variable "user_name" {
  description = "IAM user name to create"
  type        = string
}

module "iam_user" {
  source    = "../../modules/iam-user"
  user_name = var.user_name
}

accounts/account1/engineering/main.tf

// Terraform configuration for the Engineering department in Account1
terraform {
  backend "s3" {}
}

provider "aws" {
  region = var.region
}

variable "region" {
  description = "AWS region for resources"
  type        = string
}
variable "user_name" {
  description = "IAM user name to create"
  type        = string
}

module "iam_user" {
  source    = "../../modules/iam-user"
  user_name = var.user_name
}
