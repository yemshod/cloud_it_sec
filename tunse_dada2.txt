Here is your production-ready build-primerica-dev-12344567890.yml GitHub Actions workflow file, built specifically for:
	•	Account: primerica-dev-12344567890
	•	PR branch naming: primerica-dev-12344567890/<department>/<type>/<description>
	•	Department-specific matrix: automation, compliance, cspm, monitoring, scripts
	•	Vault + Terraform flow
	•	Efficient execution: only the matching matrix job runs

⸻

✅ .github/workflows/build-primerica-dev-12344567890.yml

name: Build - primerica-dev-12344567890

on:
  pull_request:
    branches: [ master ]  # Trigger only when PR is opened against master

jobs:
  build:
    name: Build (${{ matrix.department }})
    runs-on: self-hosted

    # Only run this workflow if the PR source branch starts with the correct account ID
    if: startsWith(github.head_ref, 'primerica-dev-12344567890/')

    strategy:
      matrix:
        department: [automation, compliance, cspm, monitoring, scripts]

    defaults:
      run:
        working-directory: ${{ matrix.department }}/pri-aws-accounts/primerica-dev-12344567890/

    steps:

      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Skip if department doesn’t match branch path
        if: ${{ !startsWith(github.head_ref, format('primerica-dev-12344567890/{0}/', matrix.department)) }}
        run: |
          echo "Skipping ${{ matrix.department }} — branch is not for this department."
          exit 0

      - name: Setup proxy
        uses: pri-actions/setup-proxy@v0.0.2

      - name: Import Vault secrets for AWS access
        id: secrets
        uses: pri-actions/vault-action@v2.1.2
        with:
          url: https://vaultsb.exactt.com
          method: approle
          roleId: ${{ secrets.VAULTSB_ROLE_ID }}
          secretId: ${{ secrets.VAULTSB_SECRET_ID }}
          tlsSkipVerify: true
          secrets: |
            secret/data/aws/primerica-dev-12344567890/github-actions AWS_ACCESS_KEY_ID | AWS_ACCESS_KEY_ID ;
            secret/data/aws/primerica-dev-12344567890/github-actions AWS_SECRET_ACCESS_KEY | AWS_SECRET_ACCESS_KEY ;

      - name: Git config for private GitHub (optional)
        run: |
          git config --global url."https://foo:${{ steps.secrets.outputs.github_token }}@git01.exactt.com".insteadOf "https://git01.exactt.com"

      - name: Setup Terraform
        uses: pri-actions/setup-terraform@v1.8.5

      - name: Terraform Init
        run: terraform init -backend-config=../../backend.s3.tfbackend
        env:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}

      - name: Terraform Plan
        run: terraform plan -var-file=../../terraform.tfvars
        env:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}

      - name: Post cleanup
        if: always()
        run: rm -f ~/.gitconfig



⸻

✅ Example PR Branches That Trigger Correctly

Branch Name	Matrix Job Triggered
primerica-dev-12344567890/automation/feature/add-tags	automation
primerica-dev-12344567890/compliance/bugfix/guardrails	compliance
primerica-dev-12344567890/scripts/chore/cleanup	scripts



⸻

✅ Advantages
	•	Prevents unintended jobs from running
	•	Works with multiple departments under same account
	•	Scalable: Copy-paste this structure to create build-primerica-dev-<accountN>.yml files
	•	Works in concert with deploy-* workflows triggered via /ok-to-apply or labels

⸻

Let me know if you want:
	•	The matching deploy-primerica-dev-12344567890.yml
	•	A version that logs skipped jobs for audit
	•	Or a table you can share with teammates outlining branch naming rules for all accounts



iiiiiiioooooii

jobs:
  build:
    name: Build (${{ matrix.department }})
    runs-on: self-hosted

    if: startsWith(github.head_ref, 'primerica-dev-12344567890/')

    strategy:
      matrix:
        department: [automation, compliance, cspm, monitoring, scripts]

    defaults:
      run:
        working-directory: ${{ matrix.department }}/pri-aws-accounts/primerica-dev-12344567890/

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Skip irrelevant department
        run: |
          echo "Branch: ${{ github.head_ref }}"
          echo "Department: ${{ matrix.department }}"
          
          if [[ "${{ github.head_ref }}" != primerica-dev-12344567890/${{ matrix.department }}/* ]]; then
            echo "Skipping ${{ matrix.department }} — no matching path"
            exit 0
          fi

      # Secure proxy, secrets, and Terraform steps below — only run for matching department




iiiiiiiiiiiiiiiii



Excellent clarification — and yes, this is a common and advanced use case in modular IAC design:

You have a static path like:
cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/
but inside it, there are dynamic subfolders like:
	•	devops-roles/
	•	sec-roles/
	•	platform-team-policies/

And you want to:
	•	Trigger the job only if the PR modifies something in one of these subfolders
	•	Run terraform init/plan only in the subfolder that was touched

⸻

✅ Ideal Outcome

If a PR is raised from:

primerica-dev-12344567890/automation/feature/add-sec-roles

And files changed in:

cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/sec-roles/main.tf

Then:
	•	The build-automation job should run
	•	terraform init/plan should execute in .../sec-roles/ (not the parent folder)

⸻

✅ Solution: Detect the Changed Subfolder Dynamically

Here’s the clean pattern to use:

1. Remove static working-directory from defaults:

We’ll handle it explicitly and dynamically.

# Remove this block entirely
defaults:
  run:
    working-directory: ...



⸻

2. Use tj-actions/changed-files to get changed subfolder

- name: Get changed directories
  id: changed
  uses: tj-actions/changed-files@v44
  with:
    dir_names: "true"
    files: |
      cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/**/*

This will give you something like:

changed_directories=cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/sec-roles



⸻

3. Extract the correct subfolder path dynamically

- name: Set deployment folder
  id: set_folder
  run: |
    echo "Detected directories: ${{ steps.changed.outputs.all_changed_files }}"
    folder=$(echo "${{ steps.changed.outputs.all_changed_files }}" | grep 'cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/' | head -n 1)
    echo "TF_FOLDER=$folder" >> $GITHUB_ENV

Now you have a GitHub environment variable TF_FOLDER with the path:

cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/sec-roles



⸻

4. Run Terraform Commands in the Detected Folder

- name: Terraform Init
  working-directory: ${{ env.TF_FOLDER }}
  run: terraform init -backend-config=../../backend.s3.tfbackend
  env:
    AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
    AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}

- name: Terraform Plan
  working-directory: ${{ env.TF_FOLDER }}
  run: terraform plan -var-file=../../terraform.tfvars
  env:
    AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
    AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}



⸻

✅ Optional: Fail Early if No Matching Folder Found

- name: Fail if no valid subdirectory found
  if: ${{ env.TF_FOLDER == '' }}
  run: |
    echo "No Terraform subfolder found in the changed files. Failing intentionally."
    exit 1



⸻

✅ Final Benefits

Feature	Supported?
Dynamic subfolders per department	Yes
Per-account logic	Yes
PRs scoped to changed content	Yes
Reliable Terraform backend alignment	Yes



⸻

Let me know if you’d like this logic fully embedded in the build-automation job YAML for copy-paste use — I’ll provide it.



ghhhghhhhhhhhhhhh


jobs:
  build-automation:
    name: Build (automation)
    if: startsWith(github.head_ref, 'primerica-dev-12344567890/automation/')
    runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup proxy
        uses: pri-actions/setup-proxy@v0.0.2

      - name: Import Vault secrets for AWS auth
        id: secrets
        uses: pri-actions/vault-action@v2.1.2
        with:
          url: https://vaultsb.exactt.com
          method: approle
          roleId: ${{ secrets.VAULTSB_ROLE_ID }}
          secretId: ${{ secrets.VAULTSB_SECRET_ID }}
          tlsSkipVerify: true
          secrets: |
            secret/data/aws/primerica-dev-12344567890/github-actions AWS_ACCESS_KEY_ID | AWS_ACCESS_KEY_ID ;
            secret/data/aws/primerica-dev-12344567890/github-actions AWS_SECRET_ACCESS_KEY | AWS_SECRET_ACCESS_KEY ;

      - name: Detect changed Terraform subfolder (via git)
        id: set_folder
        run: |
          echo "Scanning Git diff for changed Terraform folder..."
          folder=$(git diff --name-only origin/master...HEAD \
            | grep '^cloud-security/automation/pri-aws-accounts/primerica-dev-12344567890/' \
            | cut -d '/' -f1-6 \
            | uniq \
            | head -n 1)

          if [ -z "$folder" ]; then
            echo "No Terraform directory detected — exiting safely."
            exit 1
          fi

          echo "TF_FOLDER=$folder" >> $GITHUB_ENV
          echo "Detected Terraform folder: $folder"

      - name: List contents of TF_FOLDER (debug)
        run: ls -la ${{ env.TF_FOLDER }}

      - name: Setup Terraform
        uses: pri-actions/setup-terraform@v1.8.5

      - name: Terraform Init
        working-directory: ${{ env.TF_FOLDER }}
        run: terraform init -backend-config=../../backend.s3.tfbackend
        env:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}

      - name: Terraform Plan
        working-directory: ${{ env.TF_FOLDER }}
        run: terraform plan -var-file=../../terraform.tfvars
        env:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}

      - name: Cleanup Git config
        if: always()
        run: rm -f ~/.gitconfig
