Interview Question: SQL Injection Detection & Prevention (Manual Code Review)
Question: “If you’re reviewing code manually, what would you look for to identify a SQL Injection (SQLi) vulnerability? And what are some practical ways you’d recommend preventing it in a real-world application?”

Why This Question Works
	•	Technical Depth: Probes database interaction security, a top OWASP risk, especially relevant for HealthStream’s patient data apps.
	•	Real-World Relevance: SQLi can lead to PHI breaches, tying into HIPAA compliance.
	•	Practicality: Assesses manual review skills and secure coding mindset.
	•	Personality Fit: Gauges teaching ability and precision under scrutiny.

Expected Strong Answer (What You Should Hear)
Part 1: What to Look for in Manual Code Review (Red Flags)
“In manual code review, I’d trace user input to SQL queries—focusing on dynamic query construction. SQLi happens when unsanitized input alters SQL logic. Key patterns:”
Red Flag
Example (Vulnerable Code)
Why It’s Dangerous
1. String Concatenation in Queries
query = "SELECT * FROM users WHERE id = " + userId;
Input like 1 OR 1=1 dumps all records
2. Direct Parameter Insertion
db.execute("SELECT * FROM patients WHERE name = '" + name + "'")
Allows ' OR '1'='1 to bypass auth
3. No Input Validation on Params
stmt = conn.prepare("SELECT * FROM records WHERE id = ?"); stmt.setString(1, id); (if no type checks)
Blind SQLi via type confusion (e.g., int as string)
4. Dynamic Table/Column Names
query = "SELECT * FROM " + tableName + " WHERE col = " + value;
Input like users; DROP TABLE patients -- executes arbitrary SQL
5. ORM Misuse (e.g., Raw SQL in Entity Framework)
context.Database.ExecuteSqlRaw("UPDATE users SET pass = {0}", rawPassword);
Bypasses ORM protections if inputs aren’t parameterized
6. Stored Procedures Without Params
EXEC GetUser @id = '" + id + "'
Concatenated params enable injection in procs
“I’d also scan for missing parameterization, inconsistent escaping, or union-based payloads in logs. Context matters: watch for second-order SQLi where input is stored then queried later.”

Part 2: Prevention Strategies (Defense-in-Depth)
“Prevention is about parameterized queries and prepared statements—never trust input. Here’s a layered approach:”
Layer
Recommendation
Implementation Example
1. Parameterized Queries (Primary Fix)
Use placeholders for all inputs
Java: PreparedStatement pst = conn.prepare("SELECT * FROM users WHERE id = ?"); pst.setInt(1, userId);
Python: cursor.execute("SELECT * FROM users WHERE id = %s", (userId,))
2. Stored Procedures with Params
Bind inputs safely in DB
SQL: CREATE PROC GetUser @id INT AS SELECT * FROM users WHERE id = @id;
3. Input Validation + Sanitization
Whitelist expected formats
Reject non-integers for IDs; use regex for names (e.g., no -- or /*)
4. ORM Best Practices
Avoid raw SQL; use query builders
Entity Framework: context.Users.Where(u => u.Id == userId).ToList();
5. Web Application Firewall (WAF)
Block common payloads
AWS WAF rule: Block UNION SELECT, 1=1 -- with high confidence
6. Least Privilege DB Accounts
Limit user perms
App DB user: SELECT/INSERT only, no DROP/ALTER
7. Invicti/Snyk Scans in CI/CD
Automate detection
Fail builds on SQLi findings (OWASP ZAP integration)
“Add error handling to suppress SQL errors (e.g., generic ‘Query failed’) and logging without exposing schema. For HealthStream, ensure HIPAA-aligned auditing of failed queries.”

Bonus: Pro-Level Insight (Standout Candidates Say This)
“I’d differentiate first-order (immediate) vs. second-order SQLi (stored input). Test for blind/time-based variants with tools like sqlmap post-review. Align with OWASP Top 10 A03: Injection.”

Evaluation Rubric (What You’re Scoring)
Criteria
Strong (5)
Weak (1–2)
Pattern Recognition
Identifies 4+ code smells (e.g., concatenation) with examples
Says “look for quotes” vaguely
Context Awareness
Covers dynamic queries, ORMs, stored procs
Ignores parameterization nuances
Defense-in-Depth
Emphasizes params + WAF + validation
Relies solely on “sanitize input”
Tooling & Process
Mentions Invicti, CI/CD, OWASP
No automation or compliance tie-in
Clarity & Confidence
Explains with code snippets
Hesitant or overly generic

Final Verdict
	•	Move to Tech Screen if they nail parameterization as the core fix and list 3+ layers.
	•	Drop if they suggest “escape quotes” without params or miss DB privilege limits.
This question complements XSS review, testing holistic injection defenses for your AppSec role.


------

Interview Question: XSS Detection & Prevention (Manual Code Review)
Question: “If you’re reviewing code manually, what would you look for to identify a Cross-Site Scripting (XSS) vulnerability? And what are some practical ways you’d recommend preventing it in a real-world application?”

Why This Question Works
	•	Technical Depth: Tests hands-on AppSec knowledge without needing tools.
	•	Real-World Relevance: XSS is a top OWASP risk and common in web apps like HealthStream’s patient portal.
	•	Practicality: Forces the candidate to think like a reviewer and a defender.
	•	Personality Fit: Reveals clarity, precision, and teaching ability.

Expected Strong Answer (What You Should Hear)
Part 1: What to Look for in Manual Code Review (Red Flags)
“When manually reviewing code for XSS, I focus on where user input meets output—especially in HTML, JavaScript, or JSON contexts. Here are the key patterns I look for:”
Red Flag
Example (Vulnerable Code)
Why It’s Dangerous
1. Direct innerHTML or document.write()
element.innerHTML = userInput;
Injects raw HTML/JS into DOM
2. Unescaped dynamic values in HTML
Hello, <%= username %>
Allows
Bypasses HTML escaping
5. JSON responses used in
Turns JSON into executable JS
6. DOM-based XSS via location.hash, document.URL
document.getElementById('output').innerHTML = location.hash;
Client-side injection
“I’d also check if input validation is missing or output encoding is inconsistent—especially across different contexts (HTML, JS, attributes, CSS).”

Part 2: Prevention Strategies (Defense-in-Depth)
“XSS prevention follows ‘never trust input, always escape output’. Here’s how I’d secure it:”
Layer
Recommendation
Implementation Example
1. Output Encoding (Primary Fix)
Use context-aware escaping
htmlEscape(userInput) in HTML
jsEscape() in
