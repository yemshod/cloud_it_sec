Interview Question: SQL Injection Detection & Prevention (Manual Code Review)
Question: “If you’re reviewing code manually, what would you look for to identify a SQL Injection (SQLi) vulnerability? And what are some practical ways you’d recommend preventing it in a real-world application?”

Why This Question Works
	•	Technical Depth: Probes database interaction security, a top OWASP risk, especially relevant for HealthStream’s patient data apps.
	•	Real-World Relevance: SQLi can lead to PHI breaches, tying into HIPAA compliance.
	•	Practicality: Assesses manual review skills and secure coding mindset.
	•	Personality Fit: Gauges teaching ability and precision under scrutiny.

Expected Strong Answer (What You Should Hear)
Part 1: What to Look for in Manual Code Review (Red Flags)
“In manual code review, I’d trace user input to SQL queries—focusing on dynamic query construction. SQLi happens when unsanitized input alters SQL logic. Key patterns:”
Red Flag
Example (Vulnerable Code)
Why It’s Dangerous
1. String Concatenation in Queries
query = "SELECT * FROM users WHERE id = " + userId;
Input like 1 OR 1=1 dumps all records
2. Direct Parameter Insertion
db.execute("SELECT * FROM patients WHERE name = '" + name + "'")
Allows ' OR '1'='1 to bypass auth
3. No Input Validation on Params
stmt = conn.prepare("SELECT * FROM records WHERE id = ?"); stmt.setString(1, id); (if no type checks)
Blind SQLi via type confusion (e.g., int as string)
4. Dynamic Table/Column Names
query = "SELECT * FROM " + tableName + " WHERE col = " + value;
Input like users; DROP TABLE patients -- executes arbitrary SQL
5. ORM Misuse (e.g., Raw SQL in Entity Framework)
context.Database.ExecuteSqlRaw("UPDATE users SET pass = {0}", rawPassword);
Bypasses ORM protections if inputs aren’t parameterized
6. Stored Procedures Without Params
EXEC GetUser @id = '" + id + "'
Concatenated params enable injection in procs
“I’d also scan for missing parameterization, inconsistent escaping, or union-based payloads in logs. Context matters: watch for second-order SQLi where input is stored then queried later.”

Part 2: Prevention Strategies (Defense-in-Depth)
“Prevention is about parameterized queries and prepared statements—never trust input. Here’s a layered approach:”
Layer
Recommendation
Implementation Example
1. Parameterized Queries (Primary Fix)
Use placeholders for all inputs
Java: PreparedStatement pst = conn.prepare("SELECT * FROM users WHERE id = ?"); pst.setInt(1, userId);
Python: cursor.execute("SELECT * FROM users WHERE id = %s", (userId,))
2. Stored Procedures with Params
Bind inputs safely in DB
SQL: CREATE PROC GetUser @id INT AS SELECT * FROM users WHERE id = @id;
3. Input Validation + Sanitization
Whitelist expected formats
Reject non-integers for IDs; use regex for names (e.g., no -- or /*)
4. ORM Best Practices
Avoid raw SQL; use query builders
Entity Framework: context.Users.Where(u => u.Id == userId).ToList();
5. Web Application Firewall (WAF)
Block common payloads
AWS WAF rule: Block UNION SELECT, 1=1 -- with high confidence
6. Least Privilege DB Accounts
Limit user perms
App DB user: SELECT/INSERT only, no DROP/ALTER
7. Invicti/Snyk Scans in CI/CD
Automate detection
Fail builds on SQLi findings (OWASP ZAP integration)
“Add error handling to suppress SQL errors (e.g., generic ‘Query failed’) and logging without exposing schema. For HealthStream, ensure HIPAA-aligned auditing of failed queries.”

Bonus: Pro-Level Insight (Standout Candidates Say This)
“I’d differentiate first-order (immediate) vs. second-order SQLi (stored input). Test for blind/time-based variants with tools like sqlmap post-review. Align with OWASP Top 10 A03: Injection.”

Evaluation Rubric (What You’re Scoring)
Criteria
Strong (5)
Weak (1–2)
Pattern Recognition
Identifies 4+ code smells (e.g., concatenation) with examples
Says “look for quotes” vaguely
Context Awareness
Covers dynamic queries, ORMs, stored procs
Ignores parameterization nuances
Defense-in-Depth
Emphasizes params + WAF + validation
Relies solely on “sanitize input”
Tooling & Process
Mentions Invicti, CI/CD, OWASP
No automation or compliance tie-in
Clarity & Confidence
Explains with code snippets
Hesitant or overly generic

Final Verdict
	•	Move to Tech Screen if they nail parameterization as the core fix and list 3+ layers.
	•	Drop if they suggest “escape quotes” without params or miss DB privilege limits.
This question complements XSS review, testing holistic injection defenses for your AppSec role.


------

Here’s XSS and SQLi explained in simple, non-technical terms — perfect for explaining to junior devs, stakeholders, or even non-tech folks:

XSS (Cross-Site Scripting)
Simple Definition:
“XSS is when an attacker tricks your website into running their JavaScript code in your users’ browsers.”
Real-Life Analogy: Imagine a public comment box on a hospital patient portal.
	•	A hacker types: 
	•	The website shows this comment without cleaning it
	•	Every visitor’s browser runs the hacker’s code → steals login cookies → hacker logs in as them.
3 Types (Keep It Simple):
Type
What Happens
Stored
Bad code saved in DB (e.g., comment) → affects everyone
Reflected
Bad code in URL (e.g., search) → affects only that user
DOM-based
Bad code runs in browser JavaScript
Prevention (1-Line Fix):
Never trust user input. Always escape it before showing on screen.

SQL Injection (SQLi)
Simple Definition:
“SQLi is when an attacker tricks your app into running their SQL commands in your database.”
Real-Life Analogy: Login form asks: "Enter your Patient ID:"
	•	Hacker types: 123 OR 1=1 --
	•	App builds query: SELECT * FROM patients WHERE id = '123 OR 1=1 --'
	•	
	•	Database says: “True!” → logs hacker in as everyone
Result?
	•	See all patient records
	•	Delete data
	•	Steal PHI (HIPAA violation)
Prevention (1-Line Fix):
Never build SQL by gluing strings. Use parameterized queries (placeholders).

Side-by-Side Summary (1 Sentence Each)
Vulnerability
Attacker Injects
Into
Result
XSS
JavaScript
Web page (browser)
Runs in user’s browser → steals sessions
SQLi
SQL commands
Database query
Runs in database → leaks or deletes data

Bottom Line for HealthStream:
XSS = Browser Attack → Steals user sessions SQLi = Database Attack → Steals patient data
Both are preventable with proper input handling — and must be blocked to protect PHI and avoid breaches.
